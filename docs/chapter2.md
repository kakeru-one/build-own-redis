# 02. Socket Programming Concepts

## 2.1 What is a Socket?
「ソケットとは、ネットワーク上で2つの当事者が通信するためのチャンネルです。“ソケット”という名前は、壁のコンセントとは無関係です。

### クライアント・サーバーモデル
Redisのような多くのユースケースでは、チャンネルを開始する側を“クライアント”、新しいクライアントを待つ側を“サーバー”と呼びます。

おもちゃのような単純なサーバーではなく、複数のクライアントを同時に扱えるサーバーに焦点を当てます。

### リクエスト・レスポンスモデル
多くのクライアント・サーバーアプリケーションはリクエスト・レスポンスモデルを採用しています。

- クライアントは1つのリクエストを送り、1つのレスポンスを待ちます。
- サーバーはリクエストごとに処理を行い、レスポンスを送信します。

リクエスト・レスポンスの例として、DNS、HTTP/1.1、Redisが挙げられます。

### TCP、UDP、そしてアプリケーション
チャンネルには2つの種類があります：パケットベースとバイトストリームベース。各々がアプリケーションに異なる機能を提供します。

UDPはパケットベースです。パケットとは、アプリケーションの観点で一定のサイズを持つメッセージです。しかし、RedisはTCPベースなので、ここではUDPを無視します。

TCPは連続したバイトストリームを提供します。メッセージとは異なり、バイトストリームには境界がないため、これがTCPを理解する上での大きな難点です！だからこそ、自分でRedisをコードすることが重要なのです。」

## 2.2 TCP/IPの簡単な復習

### プロトコルの層
ネットワークプロトコルは異なる層に分けられており、上位の層は下位の層に依存しており、それぞれの層が異なる機能を提供しています。

```
  top
   / \    | App |   メッセージやデータ
   ||     | TCP |   バイトストリーム
   ||     | IP  |   パケット
   ||     | ... |
 bottom
```

TCPの下位層はIP層です。各IPパケットは以下の3つの要素から成るメッセージです：

- 送信者のアドレス
- 受信者のアドレス
- メッセージデータ

### TCP: 信頼性のあるバイトストリーム
パケットベースの通信は簡単ではありません。アプリケーションが解決しなければならない多くの問題があります。

- メッセージデータが1つのパケットの容量を超えた場合はどうするか？
- パケットが失われた場合はどうするか？
- パケットが順番通りに届かなかった場合はどうするか？
- 接続の寿命をどう管理するか？

これらの問題を簡単にするために、次の層がIPパケットの上に追加されました。TCPが提供するのは以下の機能です：

- パケットではなくバイトストリーム
- 信頼性があり、順序が保証されたデリバリー

バイトストリームは単に順序付けられたバイトの列です。これらのバイトを理解するためにアプリケーションではなくプロトコルが使用されます。プロトコルはファイルフォーマットのようなもので、全体の長さが不明であり、1回の読み取りでデータが処理されます。

UDPはTCPと同じ層に位置していますが、依然として下位層のようにパケットベースです。UDPはIPパケットにポート番号を追加するだけです。

## 2.3 ソケットの基本概念
使用する言語やプラットフォームに関わらず、知っておくべき基本的な概念があります。

### アプリケーションはソケットを不透明なOSハンドルで参照する
TwitterユーザーをTwitterハンドルで参照するのと同じように、アプリケーションもソケットをOSが提供するハンドルで参照します。

Linuxでは、ハンドルは「ファイルディスクリプタ（fd）」と呼ばれ、プロセスに対して一意の整数値です。「ファイルディスクリプタ」という名前は単なる名前で、ファイルとは関係なく、特定のものを説明するわけでもありません。

Linuxでは、`socket()`システムコールを使ってソケットfdを割り当て、その後通信チャンネルを作成します。

ソケットを使い終わったら、リソースをOS側で解放するためにハンドルを閉じる必要があります。

### リスニングソケットと接続ソケット
TCPサーバーは特定のアドレス（IP + ポート）でリスニングし、そのアドレスからクライアント接続を受け入れます。リスニングアドレスもソケットfdで表されます。そして、新しいクライアント接続を受け入れると、そのTCP接続のソケットfdが返されます。

2種類のソケットハンドルがあります：

1. **リスニングソケット**: アドレスでリスニングすることで取得。
2. **接続ソケット**: リスニングソケットからクライアント接続を受け入れることで取得。

Linuxにおける関連するシステムコール：

- `bind()`: ソケットのリスニングアドレスを設定。
- `listen()`: ソケットをリスニングソケットにする。
- `accept()`: クライアント接続ソケットを返す（利用可能な場合）。

疑似コードでは次のようになります。

```
fd = socket()
bind(fd, address)
listen(fd)
while True:
    conn_fd = accept(fd)
    do_something_with(conn_fd)
    close(conn_fd)
```

<details>
<summary>疑似コードの解説</summary>

1.	リスニングソケットのファイルディスクリプタ（fd）:
socket() 関数で生成され、bind() 関数で特定のアドレスに関連付けられ、listen() 関数でクライアント接続を待機するためのソケットとして設定されます。このファイルディスクリプタはサーバーがクライアント接続を受け入れるために使われます。

2.	接続ソケットのファイルディスクリプタ（conn_fd）:
accept() 関数が呼ばれるたびに新しいクライアント接続を受け入れるために生成されます。このファイルディスクリプタは、クライアントとの通信に使われます。do_something_with(conn_fd) でクライアントとのやり取りが行われ、処理が終わると close(conn_fd) で閉じられます。

つまり、リスニングソケット用のファイルディスクリプタ（fd） と、クライアント接続用のファイルディスクリプタ（conn_fd） が別々に存在します。リスニングソケットはサーバーが接続を待ち続けるために使用され、クライアント接続が新たに来るたびに accept() で新しい接続ソケットが生成されます。
</details>



### 読み込みと書き込み
送信と受信は、それぞれ「読み込み（read）」と「書き込み（write）」とも呼ばれます。Linuxにはさまざまな引数を持つ多くのシステムコールがあります。

| **読み込み** | **書き込み** | **説明** |
|-------------|--------------|----------|
| read        | write        | 1つの連続したバッファで読み書きする。 |
| readv       | writev       | 複数のバッファで読み書きする。 |
| recv        | send         | 追加のフラグがある。 |
| recvfrom    | sendto       | リモートアドレスの取得/設定も行う（パケットベース）。 |
| recvmsg     | sendmsg      | readv/writevと同様だが、さらに多くのフラグや制御がある。 |
| recvmmsg    | sendmmsg     | 1つのシステムコールで複数のrecvmsg/sendmsgを実行する。 |

`read()`と`write()`は最も基本的なインターフェースで、この本ではそれで十分です。他のコールは追加の制御や最適化に使われるため、無視しても構いません。

### クライアントからの接続
`connect()`システムコールは、クライアント側からTCP接続を開始するために使用されます。擬似コードは以下の通りです。

```
fd = socket()
connect(fd, address)
do_something_with(fd)
close(fd)
```

ソケットのタイプ（リスニングソケットか接続ソケットか）は、`listen()` または `connect()` システムコールが呼ばれた後に決定されます。

### まとめ: ソケットの基本操作一覧
- **リスニングソケット**:
  - `bind()` および `listen()`
  - `accept()`
  - `close()`
- **ソケットの使用**:
  - `read()`
  - `write()`
  - `close()`
- **接続の作成**: `connect()`

次の章では、実際のコードを使って始める方法について説明します。


## Reference
https://build-your-own.org/redis/02_intro_sockets
